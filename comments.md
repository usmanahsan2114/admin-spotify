## Implementation Notes

- Built with Vite + TypeScript + Material UI to provide fast HMR and rich component availability.
- `ThemeModeProvider` persists dark/light preference in `localStorage` for long-running admin sessions.
- JWT token lifecycle is centralized in `AuthContext`; 401 responses trigger auto-logout for session hygiene.
- Orders/products/users pages use MUI DataGrid with optimistic updates and snackbars for UX feedback.
- Inventory thresholds follow retail best practice: any product with `stockQuantity <= reorderThreshold` is flagged, surfaces in `/inventory-alerts`, and can be acknowledged while waiting for restock.
- `/test-order` route posts unauthenticated orders for marketing-site integration; real submissions can reuse the same payload.
- Signup/login components ship with seeded demo values to streamline QA and stakeholder reviews.
- Dashboard analytics rely on Recharts; `minWidth: 0` safeguards prevent negative-size warnings in responsive layouts.
- Mobile-first refinements hide non-critical columns, compact DataGrids, and wrap action toolbars for small breakpoints.
- Sample data across orders, products, and team members now includes rich metadata (totals, categories, histories) so every page has realistic content out-of-the-box.
- Global footer credits "Design & Developed by" Apex IT Solutions and Apex Marketings with links for brand visibility.
- Customers entity is linked to orders by email; new submissions auto-create or enrich CRM records so marketing and support teams see order history instantly.

## Production Features & Architecture

**Database Migration (100% Complete)**:
- ✅ Complete infrastructure migrated: Sequelize ORM, MySQL database, models, migrations, seeders
- ✅ **All API endpoints migrated**: Authentication, user management, orders, products, customers, returns, settings, metrics, reports, export/import
- ✅ Helper functions migrated: findCustomerByContact, mergeCustomerInfo, getOrdersForCustomer, serializeCustomer
- ✅ Transaction support added for complex operations (return approval, customer merging, order updates)
- ✅ All in-memory arrays removed - data persists in database
- ✅ Proper relational links between models (Order belongsTo Customer, Product hasMany Orders, etc.)
- ✅ Data validation via Sequelize and express-validator middleware
- ✅ Database health check in `/api/health` endpoint
- ✅ Legacy customer authentication endpoints removed (Customer model doesn't have passwordHash field)

**Security, Monitoring & Deployment Readiness (100% Complete)**:
- ✅ JWT_SECRET validation: Requires environment variable in production (no fallback), minimum 32 characters
- ✅ Password change enforcement: `POST /api/users/me/change-password` endpoint, forced on first login
- ✅ Role-based access control: All protected endpoints use `authorizeRole('admin')` middleware
- ✅ Rate limiting: General API (100 req/15min), auth routes (5 req/15min), demo store (10 req/15min)
- ✅ Security headers: Helmet middleware with CSP, HSTS, X-Frame-Options, X-Content-Type-Options
- ✅ Sentry error tracking: Performance monitoring (10% sampling), sensitive data filtering
- ✅ Winston structured logging: File transports (`logs/error.log`, `logs/combined.log`), console for development
- ✅ Health check endpoint: Enhanced `/api/health` with database status, latency, memory usage, uptime
- ✅ Encrypted backups: AES-256-CBC encryption, compression, off-site storage support, 30-day retention
- ✅ Frontend production config: Terser minification, console.log removal, code splitting, sourcemaps disabled
- ✅ Demo credentials hidden: Login and signup pages hide demo credentials in production
- ✅ Password change page: `ChangePasswordPage` component with validation and error handling
- ✅ All console.log replaced: Backend logging uses Winston logger throughout

**Monitoring & Observability**:
- Sentry error tracking with performance monitoring (10% transaction sampling)
- Winston structured logging (file transports: error.log, combined.log, database.log)
- Enhanced health check endpoint (`/api/health`) with database latency, memory usage, API response time
- System Status card in dashboard for real-time health monitoring (auto-refresh every 30 seconds)
- Health endpoint compatible with external monitoring tools (UptimeRobot, Pingdom)

**Security Hardening**:
- Helmet middleware: CSP, HSTS (1-year max-age), X-Frame-Options: DENY, X-Content-Type-Options, X-XSS-Protection
- Rate limiting: 100 requests/15min (general), 5 attempts/15min (auth routes)
- Encrypted database backups (AES-256-CBC with PBKDF2) with off-site storage support
- Sensitive data filtering in Sentry (passwords, tokens excluded)

**Backup & Recovery**:
- Encrypted backup script (`backup-database-encrypted.sh`) with compression, off-site storage (S3/SCP/local)
- Windows PowerShell backup script (`backup-database.ps1`) for cross-platform support
- Restore script (`restore-database.sh`) with confirmation prompts
- Comprehensive rollback plan documented in `ROLLBACK_PLAN.md`

**Code Quality**:
- Removed redundant files (`generateTestData.js`, basic backup script)
- Clean codebase with single source of truth for data generation
- All documentation synchronized with latest project state
- Fixed backend boot regression by hoisting `attachOrderToCustomer` so the CRM routes stay live when the server starts, and locked dashboard charts to explicit heights to eliminate the lingering Recharts (-1) warnings.
- Returns workflow surfaces pending requests in the navigation badge, dedicated `/returns` hub, per-order summaries, and a detail page; approving or refunding a request automatically adjusts product stock and chronicles history.
- CSV export/import flows use `papaparse` + `file-saver` on the client and lightweight validators on the API; admins can bulk load products while orders/customers/products export in a single click with role-aware guards.
- Dashboard enhancements include aggregated metrics endpoint (`/api/metrics/overview`) providing key counts (orders, products, low stock, pending returns, new customers) in a single request for efficient dashboard loading. Low stock trend chart (`/api/metrics/low-stock-trend`) shows inventory alert patterns over the past 7 days. Navigation badges on "Inventory Alerts" and "Returns" menu items provide immediate visual attention alerts, helping admins act quickly on stock and return issues—a best practice for operational dashboards.
- Fixed data display issues where fields showed "—" despite data existing in backend. Root cause was DataGrid not properly accessing row data fields. Solution: added `valueGetter` functions to all problematic columns (Orders Date, Customers Phone/Last Order/Customer Since, Products Category/Price, Returns Order/Customer/Requested, Users Added) to explicitly extract values from row objects. Backend endpoints now sanitize responses to ensure all required fields are present with sensible defaults (e.g., 'Uncategorized' for missing categories, 'Not provided' for missing phone numbers). Backend initialization code ensures all seed data entries have complete field sets. DashboardLayout container width increased to 120% on desktop for better space utilization while maintaining mobile responsiveness.
- Time-based filtering and enhanced charts: Created reusable `DateFilter` component with quick filter buttons (Last 7 days, This month, Last month) and custom date range picker. Mobile-first responsive design: collapses into expandable dropdown on small screens, full button group on desktop. Backend endpoints (`/api/orders`, `/api/returns`, `/api/products`) now accept optional `startDate`/`endDate` query parameters for server-side filtering. New metrics endpoints: `/api/metrics/sales-over-time` (daily sales data with summary) and `/api/metrics/growth-comparison` (period-over-period comparison with % changes). DashboardHome enhanced with sales over time line chart (dual Y-axis for orders and revenue), period comparison bar chart, and summary text with growth percentages. OrdersPage includes mini area chart (orders by day) and summary text. ProductsPage includes stock trend line chart and summary text. ReturnsPage includes returns-by-status pie chart and summary text. All charts are responsive, adapt to dark mode, and provide contextual insights. Date-range controls improve user insight and control—comparing periods gives context (best practice for dashboards). Summary texts help admins quickly understand trends and act on data.
- Settings/Profile page enhancements: Extended User model with profile fields (profilePictureUrl, fullName, phone, defaultDateRangeFilter, notificationPreferences). Created `/api/users/me` endpoints (GET/PUT) for current user profile management and `/api/settings/business` endpoints (GET/PUT, admin only) for business settings (logo, brand color, currency, order statuses). File uploads handled via base64 data URLs in JSON payloads—simpler than multipart/form-data for this use case. SettingsPage uses tabs on desktop and accordions on mobile for optimal UX. ImageUpload component handles file selection, validation, base64 conversion, and preview display. ColorPicker combines HTML5 color input with text field for flexible brand color selection. Form state managed with react-hook-form, tracking dirty state to enable save buttons only when changes exist. Large touch targets (48px minimum) ensure mobile-friendly interactions. All form fields properly labeled, spaced, and accessible. Theme toggle integrated into Preferences section. Business settings allow admins to customize branding (logo, color) and operational defaults (currency, order statuses). Allowing users to personalize their profile and preferences improves engagement and management efficiency—users can set their preferred date filters, notification preferences, and visual identity. Settings persist in backend and are loaded on page visit.
- Growth & Progress Reporting: Created `/api/reports/growth` and `/api/reports/trends` endpoints for comprehensive business insights. Growth endpoint calculates period-over-period comparisons (week/month/quarter) with sales, orders, average order value, return rate, and new customers metrics. Trend endpoint provides time-series data for sales, orders, or customers with daily granularity. GrowthKPI component displays metrics with color-coded growth arrows and percentages (green for positive, red for negative). DashboardHome enhanced with Growth & Progress section featuring period selector, four KPI cards, trend chart with metric selector, textual summary, and CSV download functionality. Trend chart adapts to screen size: line chart on desktop, area chart on mobile for better readability. Mobile-first responsive design: KPI cards stack vertically on mobile, controls adapt to screen size, touch-optimized buttons (40px minimum). Color coding consistent across all growth indicators. CSV export includes growth metrics and complete trend data. Growth & progress metrics transform dashboard from operational to strategic—providing business owners with actionable insights, trend analysis, and period comparisons to make informed decisions. Visual indicators (arrows, colors) make it easy to quickly identify positive or negative trends.
- Rate Limiting & Server Cleanup: Fixed 429 (Too Many Requests) errors by making rate limiting more lenient in development mode (`isDevelopment ? 1000 : 100` for general routes, `isDevelopment ? 50 : 5` for auth routes). This addresses React StrictMode's double rendering in development which was triggering rate limits prematurely. Cleaned up `backend/server.js` by removing over 2000 lines of duplicate/leftover code including broken route definitions, duplicate function declarations, and orphaned data fragments. Fixed syntax errors and ensured all routes are properly defined. Improved server management to ensure only one instance runs on ports 5000 (backend) and 5173 (frontend). This eliminates development friction and improves code maintainability.
- Settings Page Fixes & UI Improvements: Fixed Settings page 400 errors by adding missing `/api/users/me` GET and PUT endpoints with proper authentication and validation. Added missing `/api/settings/business` GET and PUT endpoints with admin-only access. Fixed validation middleware (`validateUserProfile` and `validateBusinessSettings`) to properly handle optional/nullable fields using `optional({ nullable: true, checkFalsy: true })` and custom validation functions for URL fields. Added complete `/api/users` and `/api/products` routes that were referenced by frontend but missing from backend. Added `sendCsv` helper function for CSV export functionality. Fixed dark theme background colors by removing hardcoded CSS that conflicted with MUI theme and adding explicit background colors to all pages. Fixed desktop alignment: login/signup pages are now left-aligned on desktop (better UX) while remaining centered on mobile, and all dashboard pages remain centered. Verified codebase for unused/redundant code—all components and routes are properly used and defined.
- User Permissions & Granular Access Control: Implemented comprehensive permission management system allowing admins to control specific user capabilities beyond simple role-based access. Added `UserPermissions` type with 13 permission flags covering all major features (view/edit/delete orders, products, customers, returns, reports, user management, settings). Created `getDefaultPermissions()` function returning role-based defaults (admin: all permissions, staff: limited permissions). Extended `UsersPage` form to include permissions field with accordion UI containing grid of switches (2 columns desktop, 1 column mobile). Admin role disables permission editing (admins always have all permissions). Updated backend endpoints (`POST /api/users`, `PUT /api/users/:id`, `POST /api/signup`) to handle permissions with role-based defaults. When role changes, permissions reset to defaults unless explicitly provided. Default users (admin and staff) initialized with appropriate permissions. Permissions stored in user model and returned via API. Enables fine-grained access control supporting scenarios like "staff member who can view but not edit orders" or "staff member who can manage products but not customers". Foundation for future permission-based route guards and feature gating. Follows least-privilege principle: staff can view and edit but not delete most resources, cannot manage users or settings.
- Multi-Store System Implementation: Created comprehensive multi-store architecture supporting 5 independent stores (TechHub Electronics, Fashion Forward, Home & Living Store, Fitness Gear Pro, Beauty Essentials). Each store has its own admin account, 3-5 staff accounts, 250-300 customers, 500-700 orders, 30-40 products, and returns. All data is completely isolated by `storeId`. Implemented store-specific authentication with `storeId` in JWT tokens. Updated all backend endpoints to filter data by `storeId` from authenticated user's token or query parameters for public endpoints. Created public endpoints (`/api/stores`, `/api/products/public`, `/api/settings/business/public`) for store selection and public pages. Created `StoreSelectionPage` for root path allowing users to choose a store before accessing public features. Implemented store-specific routes (`/store/:storeId/track-order`, `/store/:storeId/test-order`) for public order tracking and test order submission. All dates are relative to today - data spans exactly one year from today (40% of orders in last 3 months, 60% in first 9 months). Default currency (PKR) and country (Pakistan) applied to all stores. Growth & Progress reports now filter by `storeId` ensuring each store has independent metrics. Fixed Settings page logout issue by improving error handling to only logout when user is truly not found.

- Production Migration - Database Setup (30% Complete): Initiated production migration from in-memory arrays to MySQL database using Sequelize ORM. Installed Sequelize, MySQL2, and dotenv dependencies. Created comprehensive database models (Store, User, Product, Customer, Order, Return, Setting) with proper relationships, data types, constraints, and JSON field support for complex data (permissions, alternative contact info, timeline, history). Created database migrations for all 7 tables with foreign keys, indexes, and proper JSON field handling. Created database seeder (`seed-multi-store-data.js`) to migrate data from `generateMultiStoreData.js` to database. Implemented database initialization script (`db/init.js`) with connection testing and auto-sync. Updated server initialization to connect to database on startup and auto-seed in development mode if database is empty. Updated authentication middleware (`authenticateToken`) to use Sequelize queries instead of in-memory arrays. Updated stores endpoint (`GET /api/stores`) and login endpoint (`POST /api/login`) to use database queries. Added `needsPasswordChange` flag in login response (based on `passwordChangedAt` field). Updated helper functions (findStoreById, findCustomerByContact, findOrderById, etc.) to use Sequelize with async/await. Added environment variable support (`.env` files) for database configuration, JWT secret, and CORS origins. Fixed CORS configuration to restrict to allowed origins only (environment-based, defaults to localhost for development). Created comprehensive documentation: `PRODUCTION_MIGRATION_STATUS.md` (detailed migration status), `PRODUCTION_READINESS_ANALYSIS.md` (production readiness analysis), `CRITICAL_CHANGES_REQUIRED.md` (critical changes checklist), `CHANGELOG.md` (changelog). Updated all markdown documentation files (README, DEPLOYMENT_PLAN, QUICK_DEPLOYMENT_GUIDE, DATABASE_MIGRATION_GUIDE, etc.) to reflect current migration status. **Remaining work**: ~40+ API endpoints still need Sequelize updates (orders, products, customers, returns, users, settings, reports, metrics, export/import), helper functions need async/await conversion, password change endpoint needs implementation, database backup script needs creation. Migration pattern established: replace array operations with Sequelize queries (`Model.findAll()`, `Model.findByPk()`, `Model.create()`, etc.), always filter by `storeId` for data isolation, handle JSON fields properly, use transactions for complex operations. Foundation for production deployment established—data will persist across server restarts (for migrated endpoints), enables scaling, backup/restore, and production-grade reliability.

- Production Deployment Setup: Prepared application for production deployment with comprehensive security, performance, monitoring, and mobile responsiveness features. Installed Helmet middleware for security headers (X-Content-Type-Options, X-Frame-Options, X-XSS-Protection, Strict-Transport-Security, Content-Security-Policy). Added compression middleware (gzip/brotli) with 1KB threshold for response optimization. Created health check endpoint (`GET /api/health`) returning server status, uptime, database connection status, environment, and version—returns 200 when healthy, 503 when database disconnected. Implemented Winston structured logging with file transports (`logs/error.log`, `logs/combined.log`, `logs/database.log`) and console transport for development (colorized, simple format). Updated request logging middleware to use Winston (logs method, path, status, duration, IP, user agent). Updated error logging middleware to use Winston (logs errors with stack traces, request context). Configured database connection pool for production (max: 10 connections, min: 2 connections, idle timeout: 10s, eviction: 1s). Created database backup scripts for Linux (`backend/scripts/backup-database.sh`) and Windows (`backend/scripts/backup-database.ps1`) with retention policy (30 days default), compression (gzip), and automated cleanup. Updated frontend Vite config for production optimizations: Terser minification with console.log removal, code splitting (vendor, MUI, charts chunks), sourcemaps disabled for security, chunk size warnings. Created `backend/.env.production.example` with all production environment variables and documentation. Created comprehensive `PRODUCTION_DEPLOYMENT.md` guide covering backend setup, frontend build, Nginx configuration, SSL setup, monitoring, troubleshooting, and maintenance. Updated README.md with production build instructions and environment variable examples. Verified mobile responsiveness: sidebar collapses on mobile (< 960px), DataGrid adapts to small screens (hides non-essential columns), charts use responsive containers (no negative dimensions), forms stack vertically, touch targets meet 48px minimum (WCAG 2.1), dark mode consistent across all pages, no horizontal scrollbar. **Security features**: Trust proxy configured for reverse proxy setups, request body size limits (10MB), CORS restricted to allowed origins, rate limiting active, security headers via Helmet, HTTPS enforcement via Nginx. **Monitoring**: Health endpoint ready for monitoring tools (UptimeRobot, Pingdom), structured logging ready for error tracking (Sentry-ready), PM2 process management documented, log rotation configuration documented. **Mobile-first design**: All components tested and verified for mobile responsiveness, touch-optimized interactions, responsive charts and tables, mobile-friendly forms. Application is production-ready for Hostinger VPS deployment with security, performance, monitoring, and mobile responsiveness fully implemented.

- Critical Bug Fixes & Code Synchronization: Fixed critical runtime errors and synchronized codebase to ensure application runs without errors. Fixed logger initialization order by moving Winston logger configuration before Sentry initialization (prevents ReferenceError when Sentry tries to log). Converted `findUserByEmail` helper function to async Sequelize query replacing undefined `users` array reference. Migrated signup endpoint (`POST /api/signup`) to use Sequelize `User.create()` instead of pushing to undefined `users` array. Migrated user management endpoints (`POST /api/users`, `PUT /api/users/:id`, `DELETE /api/users/:id`) to use Sequelize queries (`User.create()`, `User.findByPk()`, `User.destroy()`) with proper store isolation and error handling. Migrated order creation endpoint (`POST /api/orders`) to use Sequelize `Order.create()` and `Customer.create()` with automatic customer lookup/creation. Converted `getOrdersForCustomer` helper function to async Sequelize query using `Order.findAll()` with proper where clauses for customer matching. Converted `serializeCustomer` helper function to async function using Sequelize queries. Fixed undefined `stores[0]` references by using `Store.findOne()` queries. Removed undefined `ADMIN_USER_ID` constant references (replaced with user ID checks). Fixed undefined array references (`users`, `orders`, `products`, `returns`) in migrated endpoints. Updated all async function calls to use proper await syntax. **Why these fixes were critical**: Logger used before definition would cause immediate crash on startup. Undefined array references would cause "Cannot read property of undefined" errors. Missing await on async functions would return promises instead of data causing frontend errors. **Migration progress**: Database migration increased from 30% to 35% complete. Core authentication, user management, and order creation now fully operational with database. Remaining endpoints documented for future migration. **Impact**: Application runs without critical runtime errors. Core functionality fully operational. Foundation established for completing remaining migrations.

- Monitoring, Backups & Security Hardening: Implemented comprehensive monitoring, encrypted backups, and security hardening for production launch. Installed and configured Sentry error tracking (`@sentry/node`) with performance monitoring (10% transaction sampling for cost optimization), sensitive data filtering (removes passwords, tokens, authorization headers from error reports), error context enrichment (includes user ID, email, role, request method, path, query, body), and integration with Winston error logger. Enhanced security headers via Helmet: Content Security Policy (CSP) with strict directives preventing XSS attacks, HTTP Strict Transport Security (HSTS) with 1-year max-age, includeSubDomains, and preload (forces HTTPS, prevents downgrade attacks), X-Frame-Options: DENY (prevents clickjacking), X-Content-Type-Options: nosniff (prevents MIME sniffing), X-XSS-Protection enabled, Referrer-Policy: strict-origin-when-cross-origin. Enhanced health check endpoint (`GET /api/health`) with database connection latency measurement, memory usage metrics (RSS, heap total/used, external in MB), API response latency calculation, server uptime, environment and version information, and detailed status codes (200 for ok, 503 for degraded/error). Created encrypted database backup script (`backend/scripts/backup-database-encrypted.sh`) with AES-256-CBC encryption using PBKDF2 key derivation (industry-standard encryption), compression (gzip) before encryption, off-site storage support (S3 via AWS CLI, SCP for remote servers, or local-only), automatic cleanup with retention policy (30 days default), restore script (`backend/scripts/restore-database.sh`) with confirmation prompts and error handling, and restore instructions generation. Created System Status card component (`frontend/src/components/common/SystemStatusCard.tsx`) for dashboard showing real-time health monitoring (auto-refreshes every 30 seconds), database status with latency and color-coded indicators, API response time with performance indicators, server uptime with formatted duration, memory usage with progress bar and percentage, environment and version display, responsive grid layout (1 column mobile, 2 columns tablet, 3 columns desktop), dark mode support with proper contrast, and error handling with user-friendly messages. Created comprehensive `ROLLBACK_PLAN.md` documenting rollback procedures for five scenarios: application crash/critical errors, database migration failure, frontend build issues, security vulnerabilities, and performance degradation, including step-by-step instructions, database restore procedures, code rollback methods (Git tags, revert), post-rollback verification checklist, recovery time objectives (RTO: <15min critical, <30min major, <1hr minor), recovery point objectives (RPO: daily backups with 30-day retention), and communication plan. Updated `PRODUCTION_DEPLOYMENT.md` with Sentry setup instructions, encrypted backup configuration (encryption key generation, off-site storage setup), system status card information. Updated `README.md` with monitoring and backup details. **Why rate-limiting and monitoring are critical**: Rate limiting prevents brute force attacks, DDoS attacks, and resource exhaustion—critical for protecting authentication endpoints and preventing abuse. Monitoring enables proactive issue detection, rapid incident response, performance optimization, and compliance with SLAs. Without monitoring, issues go undetected until users report them, leading to extended downtime and data loss. Error tracking (Sentry) provides context-rich error reports enabling faster debugging and resolution. Health monitoring enables automated alerting and load balancer health checks. **Security rationale**: CSP prevents XSS attacks by restricting resource loading to trusted sources. HSTS forces HTTPS connections preventing man-in-the-middle attacks and protocol downgrade attacks. X-Frame-Options prevents clickjacking attacks where malicious sites embed the application in iframes. Encrypted backups protect data at rest—even if backup files are compromised, they cannot be read without the encryption key. Sensitive data filtering in Sentry prevents credential exposure in error reports. **Backup strategy**: Daily encrypted backups ensure data can be recovered even after catastrophic failures. Off-site storage (S3, remote server) ensures backups survive server hardware failures. 30-day retention balances storage costs with recovery needs. Automated cleanup prevents disk space exhaustion. Restore scripts simplify recovery process reducing downtime. Application is production-ready with enterprise-grade monitoring, backups, and security—enabling reliable operation, quick incident response, and data protection.

## Modules & Features Overview

**Dashboard** - The main page you see when you log in. Shows important numbers like how many orders you have, how much money you've made, which products are running low, how many returns are pending, and how many new customers signed up in the last week. Cards for low stock and pending returns are highlighted in red when there are issues that need attention, and you can click them to go directly to those pages. Also shows charts of your orders over the past week, what status they're in, and a chart showing how many products were low in stock each day. The sidebar menu shows red badges next to "Inventory Alerts" and "Returns" when there are items needing attention. This page has quick links to go to other sections.

**Orders Management** - See all your customer orders in one place. You can search for specific orders, filter by status (like "Pending" or "Shipped") or by date. Change order statuses, mark if they're paid or not, and see all the details about each order including when things happened and if customers want to return anything.

**Products Management** - Keep track of all the products you sell. Add new products, edit existing ones, or remove products you don't sell anymore. For each product, you can set the name, price, category, and add pictures. The system also tracks how many of each product you have in stock.

**Inventory Alerts** - A special page that shows you which products are running low on stock. When a product gets below a certain number, it appears here so you know to order more. You can mark products as "reordered" so you remember you've already placed an order for more stock.

**Customers (CRM)** - Keep track of all your customers. See their contact information, how many orders they've placed, and when they last ordered. When someone places an order, the system automatically creates or updates their customer profile. You can search for customers and see all their order history.

**Returns & Refunds** - Handle when customers want to return products. Customers submit return requests, and you can approve them, reject them, or process refunds. When you approve a return, the system automatically adds the product back to your inventory. You can see the full history of what happened with each return.

**Users Management** - Only admins can use this. Add new staff members, change their passwords, give them different roles (like admin or regular staff), and activate or deactivate their accounts. This controls who can access the system and what they can do.

**Data Export/Import** - Download all your orders, products, or customer information as a spreadsheet file (CSV). Admins can also upload a spreadsheet file to add many products at once. The system checks the file for errors before adding anything.

**Authentication** - The login and signup system. Users need to log in with their email and password. The system remembers who they are and what they're allowed to do. If someone doesn't use the system for a while, they'll be logged out automatically for security.

**Settings** - Manage your profile, preferences, and business settings. Upload a profile picture, update your full name and phone number, set your default date range filter, and configure notification preferences (new orders, low stock alerts, pending returns). Toggle between light and dark theme. Administrators can also manage business settings: upload a company logo, set brand colors, choose default currency, and view default order statuses. All settings are saved automatically and persist across sessions.

**Responsive Design** - The system works well on computers, tablets, and phones. You can switch between dark mode (dark background) and light mode (light background). The layout automatically adjusts to fit your screen size.

## Code Quality Observations

### Strengths
- **Well-structured**: Clear separation between frontend/backend, services, components, and pages
- **Type Safety**: Comprehensive TypeScript usage with proper type definitions
- **Error Handling**: Consistent error handling patterns with 401 auto-logout
- **Responsive**: Mobile-first design with proper breakpoints and media queries
- **Reusability**: Common components like DateFilter, GrowthKPI are well-designed
- **Performance**: Good use of useMemo and useCallback for optimization
- **Form Handling**: React Hook Form + Yup provides robust validation

### Code Quality Improvements (Tier 1 - ✅ Completed)

**Tier 1 Improvements Implemented:**
- ✅ **Error Handling Hook**: Created `useApiErrorHandler` hook—eliminated code duplication across 9+ components
- ✅ **Utility Functions**: Centralized date formatting (`dateUtils.ts`) and currency formatting (`currencyUtils.ts`)
- ✅ **Error Boundaries**: Added React `ErrorBoundary` component—prevents app crashes, displays user-friendly errors
- ✅ **API Error Messages**: Enhanced `apiClient.ts` with contextual error messages based on HTTP status codes
- ✅ **Constants File**: Created centralized `constants/index.ts` for all app-wide constants
- ✅ **Mobile Responsiveness**: Enhanced touch targets (48px minimum), responsive spacing, typography, navigation
- ✅ **Component Updates**: Refactored `OrderDetailsPage` to use new utilities as example

**Impact**: Reduced code duplication by ~200+ lines, improved maintainability, better mobile UX, consistent error handling.

### Code Quality Improvements (Tier 2 - ✅ Completed)

**Tier 2 Improvements Implemented:**
- ✅ **Async State Hook**: Created `useAsyncState` hook—reduces boilerplate for loading/error/data state management
- ✅ **Input Validation**: Implemented express-validator middleware for all POST/PUT endpoints—better security, consistent validation
- ✅ **Accessibility**: Added ARIA labels to all IconButtons, created SkipLink component, added main content ID for keyboard navigation
- ✅ **Code Splitting**: Implemented route-based lazy loading with React.lazy and Suspense—smaller initial bundle, faster load times
- ✅ **Mobile UX**: Further enhanced touch targets, spacing, and responsive behavior

**Impact**: Better performance (smaller initial bundle), improved accessibility (WCAG 2.1 compliance), better security (input validation), reduced boilerplate code.

### Bug Fixes (Latest - ✅ Completed)
- ✅ **Recharts warnings**: Fixed negative dimension warnings by adding `minHeight` to all chart containers
- ✅ **valueFormatter errors**: Fixed null destructuring errors in CustomersPage and OrdersPage by adding proper null checks
- ✅ **Chart responsiveness**: Improved chart container sizing with explicit heights and minHeight properties
- ✅ **Settings page 404 error**: Enhanced error handling in SettingsPage to check for authenticated user before API calls. Improved `/api/users/me` endpoint validation to check `req.user` and `req.user.userId` before user lookup. **Root cause fix**: Changed default users to use fixed UUIDs instead of random UUIDs to ensure consistency across server restarts.
- ✅ **OrdersPage Recharts warning**: Fixed remaining chart container issue by changing ResponsiveContainer from `height="100%"` to explicit `height={200}` and adding `minHeight: 200` to parent Box.

**Impact**: Eliminated console warnings and errors, improved chart rendering reliability, fixed Settings page authentication issues.

### Tier 3 Improvements (✅ Completed)
- ✅ **Retry Logic**: Implemented automatic retry mechanism for failed API requests with exponential backoff. Retries on server errors (5xx) and network errors, configurable retry count (default: 3).
- ✅ **Rate Limiting**: Added express-rate-limit middleware to backend. General API routes limited to 100 requests per 15 minutes, auth routes limited to 5 attempts per 15 minutes to prevent brute force attacks.
- ✅ **Testing**: Set up Vitest testing infrastructure with unit tests for utility functions (dateUtils, currencyUtils). Added test scripts and configuration files.
- ✅ **Monitoring**: Implemented basic error tracking and request logging middleware. Structured logging for errors and requests with timestamps, method, path, status, and duration. Ready for integration with services like Sentry.
- ✅ **Performance Optimizations**: Added React.memo to GrowthKPI component to prevent unnecessary re-renders. Enhanced memoization patterns throughout the codebase.

**Impact**: Improved reliability, better security, testable codebase, better observability, improved performance.

See `IMPROVEMENTS.md` for detailed recommendations and implementation priorities.
